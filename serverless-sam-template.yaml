AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Description: |
  Elastic Proxy
  Fetches observability data from your Elastic Cluster to Postman.
  
Parameters:
  ElasticClusterAliasName:
    Type: String
    Description: 'Cluster Alias Name for the Elastic Deployment'
    
  ElaticSearchAPIKey:
    Type: String
    Description: RESTful API to provide access to deployment CRUD actions
    NoEcho: true
    
  DeployInVPC:
    Type: String
    Description: >
      'Do you want to deploy this Elastic Proxy Lambda Function in a VPC? (Enter "Yes" or "No").
      Note: If yes, make sure a VPC is already been created in the region before deploying this CFT.' 
    Default: 'No'
    AllowedValues: ['Yes', 'No']
      
  VPCId:
    Type: String
    Description: 'Enter the VPC ID in which you want to deploy the Elastic Proxy Lambda Function. Provide the value only if you want to deploy the Proxy Function in the VPC'
    
  SubnetIds:
    Type: CommaDelimitedList
    Description: 'Enter the Subnet IDs (comma-separated) for the Elastic Proxy Lambda Function. Provide the value only if you want to deploy the Proxy Function in the VPC'
    ConstraintDescription: 'Please enter a valid list of Subnet IDs.'
    
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Elastic Cluster Deployment Details
        Parameters:
          - ElasticClusterAliasName
          - ElaticSearchAPIKey
    - Label:
        default: Deploy Elastic Proxy in a VPC (Optional)
        Parameters:
          - DeployInVPC
          - SubnetIds
          - VPCId
    ParameterLabels:
      ElasticClusterAliasName:
        default: Elastic Cluster Alias Name
      ElaticSearchAPIKey:
        default: ElaticSearch API Key
      DeployInVPC:
        default: Deploy Serverless Forwarder In VPC
      VPCId:
        default: VPC ID
      SubnetIds:
        default: Subnet IDs
        
Conditions:
  ShouldDeployElasticProxyInVPC: !Equals [!Ref DeployInVPC, "Yes"]
  
Mappings:
  VPCServiceName:
    af-south-1: 
      service: com.amazonaws.vpce.us-east-1.vpce-svc-0e42e1e06ed010238
    ap-east-1:
      service: com.amazonaws.vpce.ap-east-1.vpce-svc-0f96fbfaf55558d5c
    ap-northeast-1:
      service: com.amazonaws.vpce.ap-northeast-1.vpce-svc-0e1046d7b48d5cf5f
    ap-northeast-2:
      service: com.amazonaws.vpce.ap-northeast-2.vpce-svc-0d90cf62dae682b84
    ap-south-1:
      service: com.amazonaws.vpce.ap-south-1.vpce-svc-0e9c1ae5caa269d1b
    ap-southeast-1:
      service: com.amazonaws.vpce.ap-southeast-1.vpce-svc-0cbc6cb9bdb683a95
    ap-southeast-2:
      service: com.amazonaws.vpce.ap-southeast-2.vpce-svc-0cde7432c1436ef13
    ca-central-1:
      service: com.amazonaws.vpce.ca-central-1.vpce-svc-0d3e69dd6dd336c28
    eu-central-1:
      service: com.amazonaws.vpce.eu-central-1.vpce-svc-081b2960e915a0861
    eu-south-1:
      service: com.amazonaws.vpce.eu-south-1.vpce-svc-03d8fc8a66a755237
    eu-north-1:
      service: com.amazonaws.vpce.eu-north-1.vpce-svc-05915fc851f802294
    eu-west-1:
      service: com.amazonaws.vpce.eu-west-1.vpce-svc-01f2afe87944eb12b
    eu-west-2:
      service: com.amazonaws.vpce.eu-west-2.vpce-svc-0e42a2c194c97a1d0
    eu-west-3:
      service: com.amazonaws.vpce.eu-west-3.vpce-svc-0d6912d10db9693d1
    me-south-1:
      service: com.amazonaws.vpce.me-south-1.vpce-svc-0381de3eb670dcb48
    sa-east-1:
      service: com.amazonaws.vpce.sa-east-1.vpce-svc-0b2dbce7e04dae763
    us-east-1: 
      service: com.amazonaws.vpce.us-east-1.vpce-svc-0e42e1e06ed010238
    us-east-2:
      service: com.amazonaws.vpce.us-east-2.vpce-svc-02d187d2849ffb478
    us-west-1:
      service: com.amazonaws.vpce.us-west-1.vpce-svc-00def4a16a26cb1b4
    us-west-2:
      service: com.amazonaws.vpce.us-west-2.vpce-svc-0e69febae1fb91870    
  PrivateHostedZoneDNSName:
    af-south-1:
      HostedZone: vpce.af-south-1.aws.elastic-cloud.com
    ap-east-1:
      HostedZone: vpce.ap-east-1.aws.elastic-cloud.com
    ap-northeast-1:
      HostedZone: vpce.ap-northeast-1.aws.elastic-cloud.com
    ap-northeast-2:
      HostedZone: vpce.ap-northeast-2.aws.elastic-cloud.com
    ap-south-1:
      HostedZone: vpce.ap-south-1.aws.elastic-cloud.com
    ap-southeast-1:
      HostedZone: vpce.ap-southeast-1.aws.elastic-cloud.com
    ap-southeast-2:
      HostedZone: vpce.ap-southeast-2.aws.elastic-cloud.com
    ca-central-1:
      HostedZone: vpce.ca-central-1.aws.elastic-cloud.com
    eu-central-1:
      HostedZone: vpce.eu-central-1.aws.elastic-cloud.com
    eu-south-1:
      HostedZone: vpce.eu-south-1.aws.elastic-cloud.com
    eu-north-1:
      HostedZone: vpce.eu-north-1.aws.elastic-cloud.com
    eu-west-1:
      HostedZone: vpce.eu-west-1.aws.elastic-cloud.com
    eu-west-2:
      HostedZone: vpce.eu-west-2.aws.elastic-cloud.com
    eu-west-3:
      HostedZone: vpce.eu-west-3.aws.elastic-cloud.com
    me-south-1:
      HostedZone: vpce.me-south-1.aws.elastic-cloud.com
    sa-east-1:
      HostedZone: vpce.sa-east-1.aws.elastic-cloud.com
    us-east-1: 
      HostedZone: vpce.us-east-1.aws.elastic-cloud.com
    us-east-2:
      HostedZone: vpce.us-east-2.aws.elastic-cloud.com
    us-west-1:
      HostedZone: vpce.us-west-1.aws.elastic-cloud.com
    us-west-2:
      HostedZone: vpce.us-west-2.aws.elastic-cloud.com  
    
Resources:
  ElasticServerlessProxy:
    Type: AWS::Serverless::Function
    Properties:
      Handler: lambda_function.lambda_handler
      Runtime: python3.11
      CodeUri: 's3://elastic-proxy/elasticsearch-proxy.zip'
      FunctionUrlConfig:
        AuthType: NONE
        InvokeMode: BUFFERED
      Environment:
        Variables:
          ELASTICSEARCH_HOST: !If
            - ShouldDeployElasticProxyInVPC
            - !Sub "${ElasticClusterAliasName}.es.vpce.${AWS::Region}.aws.elastic-cloud.com"
            - !Sub "${ElasticClusterAliasName}.es.${AWS::Region}.aws.found.io"
          ELASTICSEARCH_API_KEY: !Ref ElaticSearchAPIKey
          Elastic_Cluster_Alias_Name: !Ref ElasticClusterAliasName
      VpcConfig:
        SecurityGroupIds: !If
          - ShouldDeployElasticProxyInVPC
          - - !GetAtt ProxyFunctionSecurityGroup.GroupId
          - []
        SubnetIds: !If
          - ShouldDeployElasticProxyInVPC
          - !Ref SubnetIds
          - []
          
  ProxyFunctionSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: ShouldDeployElasticProxyInVPC
    Properties:
      GroupDescription: Elastic Proxy SecurityGroup 
      VpcId: !Ref VPCId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 0
          ToPort: 65535
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 9243
          ToPort: 9243
          CidrIp: 0.0.0.0/0
          
  RolePolicies: 
    Type: 'AWS::IAM::Policy'
    Condition: ShouldDeployElasticProxyInVPC
    Properties: 
      PolicyName: "ElasticBootstrapLambdaCustomPolicy"
      PolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          - Effect: "Allow"
            Action:
            - "ec2:CreateSecurityGroup"
            - "ec2:AuthorizeSecurityGroupIngress"
            - "ec2:CreateVpcEndpoint"
            - "ec2:DescribeVpcEndpoints"
            - "route53:CreateHostedZone"
            - "route53:ChangeResourceRecordSets"
            - "route53:GetChange"
            - "lambda:InvokeFunction"
            - "ec2:DescribeVpcs"
            - "cloudformation:SignalResource"
            - "cloudformation:DescribeStackResources"
            - "cloudformation:DescribeStackEvents"
            - "s3:*"
            Resource: "*" 
      Roles: 
        - Ref: "BootstrapLambdaExecutionRole"
              
  BootstrapLambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Condition: ShouldDeployElasticProxyInVPC
    Properties:
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          - Effect: "Allow"
            Principal: 
              Service: 
              - "lambda.amazonaws.com"
            Action: 
              - "sts:AssumeRole"
      Path: "/"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      
  ElasticServerlessBootstrapFunction:
    Type: AWS::Lambda::Function
    Condition: ShouldDeployElasticProxyInVPC
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt BootstrapLambdaExecutionRole.Arn
      Runtime: python3.8
      Code:
        ZipFile: |
            import boto3
            import os
            import uuid
            import random
            import string
            import cfnresponse

            def create_security_group(vpc_id, group_description):
                # Generate a random suffix for the group name
                random_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))
                group_name = f'ElasticProxySecurityGroup_{random_suffix}'
                
                ec2 = boto3.resource('ec2')
                security_group = ec2.create_security_group(
                    VpcId=vpc_id,
                    GroupName=group_name,
                    Description=group_description
                )
                security_group.authorize_ingress(
                    IpProtocol='tcp',
                    FromPort=443,
                    ToPort=443,
                    CidrIp='0.0.0.0/0'
                )
                security_group.authorize_ingress(
                    IpProtocol='tcp',
                    FromPort=9243,
                    ToPort=9243,
                    CidrIp='0.0.0.0/0'
                )
                return security_group.id

            def extract_dns_entries(response):
                # Check if 'VpcEndpoint' key is present in the response
                vpc_endpoint_info = response.get('VpcEndpoint', {})

                # Extract DNS entries from 'DnsEntries' in 'VpcEndpoint' info
                dns_entries = vpc_endpoint_info.get('DnsEntries', [])

                if not dns_entries:
                    raise ValueError("VpcEndpoint DNS entries not found in the response.")

                # Use the first DNS entry for creating the CNAME record
                dns_name = dns_entries[0].get('DnsName')

                if dns_name is not None:
                    print("VPC Endpoint DNS Entry:", dns_name)
                else:
                    raise ValueError("VpcEndpoint DNS entry is None.")

                return dns_name

            def create_vpc_endpoint(vpc_id, subnet_ids, security_group_id, region, service_name):
                ec2 = boto3.client('ec2', region_name=region)
                response = ec2.create_vpc_endpoint(
                    VpcId=vpc_id,
                    ServiceName=service_name,
                    SubnetIds=subnet_ids,
                    VpcEndpointType='Interface',
                    SecurityGroupIds=[security_group_id]
                )
                
                # Ensure 'VpcEndpointId' is present in the response
                vpc_endpoint_id = response.get('VpcEndpoint', {}).get('VpcEndpointId')
                if not vpc_endpoint_id:
                    raise ValueError("VpcEndpointId not found in the response.")

                # Extract DNS entries from the response
                dns_name = extract_dns_entries(response)

                print("Create VPC Endpoint Response:", response)
                return vpc_endpoint_id, dns_name

            def create_hosted_zone(vpc_id, region, private_hosted_zone):
                route53 = boto3.client('route53')
                caller_reference = str(uuid.uuid4())
                response = route53.create_hosted_zone(
                    Name=private_hosted_zone,
                    VPC={
                        'VPCId': vpc_id,
                        'VPCRegion': region
                    },
                    CallerReference=caller_reference
                )
                # Extract Hosted Zone Id
                hosted_zone_id = response['HostedZone']['Id']
                return hosted_zone_id

            def create_cname_record(hosted_zone_id, region, dns_name):
                try:
                    print("Debug - VPC Endpoint DNS Entry:", dns_name)

                    if dns_name is not None and isinstance(dns_name, str):
                        route53 = boto3.client('route53')
                        response = route53.change_resource_record_sets(
                            HostedZoneId=hosted_zone_id,
                            ChangeBatch={
                                'Changes': [
                                    {
                                        'Action': 'CREATE',
                                        'ResourceRecordSet': {
                                            'Name': f'*.vpce.{region}.aws.elastic-cloud.com',
                                            'Type': 'CNAME',
                                            'TTL': 60,
                                            'ResourceRecords': [
                                                {
                                                    'Value': dns_name
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        )
                        # Print the response for debugging purposes
                        print(response)
                        print("Debug - CNAME Record created successfully.")
                    else:
                        print("Warning: VpcEndpoint DNS entry is None or not in the expected format.")
                except Exception as e:
                    print(f"Error creating CNAME record: {e}")
                    raise

            def lambda_handler(event, context):
                vpc_id = os.environ.get('VPC_ID')
                subnet_ids = os.environ.get('SUBNET_IDS').split(',')
                region = os.environ.get('REGION')
                service_name = os.environ.get('ServiceName')
                private_hosted_zone = os.environ.get('Private_Hosted_Zone')
                responseData = {}
                
                try:
                    security_group_id = create_security_group(vpc_id, 'Elastic Proxy SecurityGroup')
                    vpc_endpoint_id, dns_name = create_vpc_endpoint(vpc_id, subnet_ids, security_group_id, region, service_name)
                    hosted_zone_id = create_hosted_zone(vpc_id, region, private_hosted_zone)

                    # Use the DNS name obtained from create_vpc_endpoint function
                    if dns_name is not None:
                        create_cname_record(hosted_zone_id, region, dns_name)
                    else:
                        raise ValueError("VpcEndpoint DNS entry is None.")  
                    
                    cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
                except Exception as e:
                    # Send a failure response with the error reason
                    cfnresponse.send(event, context, cfnresponse.FAILED, responseData, reason=str(e))
      Timeout: 300
      Environment:
        Variables:
          VPC_ID: !Ref VPCId
          SUBNET_IDS: !Join [',', !Ref SubnetIds]
          ServiceName: 
            !FindInMap 
              - VPCServiceName
              - !Ref 'AWS::Region'
              - service
          Private_Hosted_Zone:
            !FindInMap 
              - PrivateHostedZoneDNSName
              - !Ref 'AWS::Region'
              - HostedZone
          REGION: !Sub ${AWS::Region}
    
  TriggersBootstrapLambda:
    Type: 'Custom::RunCode'
    Condition: ShouldDeployElasticProxyInVPC
    DeletionPolicy: Retain
    DependsOn: ElasticServerlessBootstrapFunction
    Properties:
      ServiceToken: !GetAtt ElasticServerlessBootstrapFunction.Arn
      
Outputs:
  ElasticProxyFunctionUrlEndpoint:
      Description: "Elastic Proxy Lambda Function URL Endpoint"
      Value:
        Fn::GetAtt: ElasticServerlessProxyUrl.FunctionUrl   